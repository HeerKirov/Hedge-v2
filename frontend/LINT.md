# Lint Document

## 文件组织规范

### 根目录
根目录的文件组织结构如下：
```
dist/                   -- build之后的输出目录
public/                 -- 不进行打包的静态资源文件，如favicon.ico
    index.html          -- 入口HTML文件
src/                    -- 源代码
    assets/             -- 进行打包的静态资源文件
    typings/            -- d.ts文件
    functions/          -- 主函数库
    utils/              -- 工具函数库

    styles/             -- 公共CSS文件，在大部分位置共享的CSS样式

    components/         -- 组件库，与业务无任何关联的、可以拿到其他项目直接复用的那类
    layouts/            -- 组件库，与业务有关联的、不属于主体组件树的、多处复用的那类
    views/              -- 视图组件库，包含根组件、构建主体组件树和视图的组件
        App.tsx         -- App根组件
        ...
    routers/            -- 路由定义
    main.ts             -- 入口文件
package.json            -- package.json
vue.config.js           -- vue配置文件
tsconfig.json           -- ts配置文件
```

### 组件
vue的TSX组件和相关的SCSS module一同构成组件类内容。组件类内容分3部分。

#### views
views文件夹存放**视图类组件**以及构成这些视图的子组件。视图组件对**业务强关联**，且很少跨视图复用。
```
views/
    App.tsx             -- vue根组件
    ViewXXX/            -- 一个视图组件
        ViewXXX/...         -- 该视图的子视图
        XXX/...             -- 复杂的子组件
        style.module.scss   -- 该组件的SCSS样式
        index.tsx           -- 该组件的TSX文件
        YYY.tsx             -- 该组件的子组件
        inject.ts           -- 以该组件为根开始向下注入的数据
```
此结构可递归嵌套。

> 子组件根据规模，有不同的可选摆放位置。  
> 如果是普通规模的小组件，平铺在文件夹下的同一级。  
> 如果是过于简单的小组件，或者是子组件的简单二级子组件，可以直接内联在同一个tsx文件中。  
> 如果子组件的规模过大，那么可以像子视图一样创建一个子文件夹存放。

> 组件使用CSS module来解决局部样式的问题。  
> 在一个组件中，组件和子组件的样式都写在`style.module.scss`文件中，使用到它的组件使用SCSS module方案注入样式。
> scss文件的编写根据组件划分。每一个组件的样式都另起一个根块。主组件的样式用`.root`。
> 局部样式命名尽量简洁，尽量使用`.className`和`> nest`关系来定义，尽量不使用使用`#id`。

### layouts
layouts文件夹存放具有强业务特征的重型组件。特征是对业务有一定关联，存在跨视图复用。  
它的文件目录结构类似，以一个文件夹为单位管理一个重型组件。
```
layouts/
    XXX/
        style.module.scss
        index.tsx
        YYY.tsx
```

### components
components文件夹存放少或无业务关联的轻型组件。
这里的组件使用单独的文件存储。
```
components/
    XXX.module.scss
    XXX.tsx
```
这里的组件通常是无业务关联的、轻型的组件。  
这里的组件大多使用单独的文件存储。

> 轻型组件通常很少有子组件，如果有，一般将其内联。

> 轻型组件的scss module文件同级同名存放并引入。

### 样式
首先，样式分为两大部分，一是重度耦合在视图和组件中的布局样式，二是没有耦合、多处复用的工具样式。
#### 布局样式
在上面的视图环节也提到了布局样式。布局样式使用`SCSS module`解决方案，是局部私密的样式。它的内容与关联的模块紧密相关。  
一般来说，稍多一些的样式，都应当尽量使用布局样式统一解决。
#### 工具样式
工具样式则以更松耦合的样式提供工具styles。它们使用普通的`SCSS`导入解决方案，全局可用。  
工具样式有这么几类：
* 外部框架的UI样式，`bulma`和`font-awesome`。这些样式奠定基本的视觉效果。
* 全局覆盖的样式，`App.scss`，它提供应用程序需要全局覆盖的样式。
* 全局变量，`variable.scss`，它提供应用程序需要全局统一的导入变量。
* 全局模板，`template.scss`，它提供应用程序经常需要复用的样式表。
* 工具类，将一些style编写为原子类，提供组合实现。

工具类提供常用的一些原子类。什么使用使用原子类，什么时候使用布局样式？  
* 原则上讲，组件中出现简单常用的样式时，可以使用原子类组合。
* 而当样式多、重复而复杂，或需要各种定制样式，例如定制尺寸和动画时，就应该把除了**UI框架**之外的样式都写成布局样式表。
* 为了解决样式重复的问题，经常用到的各种样式做成模板，统一引入。

工具样式都放在`styles`文件夹下。
```
styles/
    index.ts        -- 公共import文件
    bulma/          -- bulma相关的外部导入样式
        bulma.scss          -- 有选择地导入bulma样式
        color.scss          -- 自定义的bulma颜色样式
    components/     -- 自定义的组件样式
        ...                 -- 每个文件定义一个组件样式
    utils/          -- 自定义的工具样式
        format.scss         -- 文本和显示格式相关的样式
        layout.scss         -- 元素布局相关的样式
        display.scss        -- 元素外观和显示相关的样式
    template.scss   -- 全局模板定义
    variable.scss   -- App相关的全局的变量定义
    App.scss        -- App的全局样式
```
#### components
这里定义一些具有组件特征的样式，类似bulma的组件，这些样式应用给元素后表现出某些强烈的功能和布局特征，而不具有工具和微调性。  
每个文件定义一个组件样式，或一组相近的组件样式。
#### bulma
这里定义bulma相关的样式。
#### utils
这里主要是工具样式，以及对bulma扩展的工具样式。

### 代码
#### routers
这里定义程序的路由规则。

#### functions
这里定义业务相关的函数库。  
以文件夹为单位分开定义。大部分情况下，这里的产出会是`vue hooks`函数或插件。
* `adapter-ipc`: 与来自client的IPC接口对接，提供API函数包装。
* `adapter-http`: 与来自server的HTTP接口对接，提供API函数包装，并在函数包装的基础上提供http client封装。
* `service`: 前端的大业务层。将来自ipc、http等的功能包装为一个一个的服务模块，通过install plugin->use的方式提供。这层包装会将API包装为VCA，抹去其remote API特征。
* `document`: 与web document相关的功能的hooks函数。
* `notification`: 提供消息通知框服务。
* `message-box`: 提供简单对话框服务。

#### utils
这里定义业务无关的工具函数库。

### Tips
#### 状态共享和数据传递
在vue中，有两种方式在组件之间传递共享的数据。这两种方式在本项目中如何使用存在明确的规定。
##### provide/inject
在主体视图中，与业务强关联，视图很重，各个组件构成组件树，耦合性很强。此时，主要数据由`provide/inject`来提供。  
具有关联性质的数据(例如同一个功能视图中的数据)需要被提升到一个共同的父组件中，在此定义重量级的数据结构，并`provide`。在使用到数据的子组件`inject`。

此外，还存在一些并非主体业务的重型组件，需要使用`provide/inject`提升效率。但尽量不应该让这些组件通过`injectionKey`对外提供数据。

总结，依赖注入用于：
* 强关联、强业务的数据视图在组件树内向下共享。
* 在重型组件内优化数据传递效率。

#### props/emits
在主体业务内，不属于视图共享的、只在一部分组件之间传递内容，显然不应该提升到数据视图中。这部分数据应该使用`props/emits`来传递。

此外，轻型组件、无业务关联的独立组件(`layouts`/`components`中的组件)，它们仍然应该使用属性对外传递数据。

总结，属性用于：
* 强业务的组件树内，局部的数据传递。
* 独立组件、无业务组件、轻量组件的对外数据传递。
