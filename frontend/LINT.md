# Lint Document
## 代码组织规范
根目录的文件组织结构如下：
```
dist/                   -- build之后的输出目录
public/                 -- 不进行打包的静态资源文件，如favicon.ico
src/                    -- 源代码
    assets/             -- 进行打包的静态资源文件
    typings/            -- d.ts文件
    functions/          -- 主函数库
    utils/              -- 工具函数库

    styles/             -- 公共CSS文件，在大部分位置共享的CSS样式

    components/         -- 组件库，与业务无任何关联的、可以拿到其他项目直接复用的那类
    layouts/            -- 组件库，与业务有关联的、不属于主体组件树的、多处复用的那类
    views/              -- 视图组件库，包含根组件、构建主体组件树和视图的组件
        App.tsx         -- App根组件
        ...
    routers/            -- 路由定义
    main.ts             -- 入口文件
index.html              -- 入口HTML文件
package.json            -- package.json
vite.config.ts          -- vite配置文件
```
### views
views文件夹以组件树的形式存放视图组件。这里的组件都是主体视图组件，及构成这些视图的子组件；对业务有强关联；基本不会跨视图复用。  
每一个视图组件都组织为:
```
views/
    组件名/              -- 组件目录
        style.scss      -- 组件内的CSS样式
        index.tsx       -- 组件文件
        ...             -- 该组件的子组件
```
此结构可递归嵌套。
通常来说，子组件属于局部组件时，应使用简单模式；而子组件为复杂/全局组件(内嵌视图、子视图)时，应嵌套文件夹，给子组件单独的域。  
另外，内嵌的子视图也应作为子组件处理。
#### 主体组件树的样式
一般而言，主体组件树的样式不会复用。在views中的所有组件，除非无关紧要/没有专有样式，都应该首先命名其id=`组件名称的横线样式`。  
而在一个文件夹中，`index.tsx`主组件和其子组件的CSS样式都写在`style.scss`文件中。  
* 主组件的css selector应该为`#app #父视图组件nested #主组件的名称`。这样防止重名的子视图出现问题。  
* 子组件单独列项为`#app #父视图组件nested #主组件的名称 #当前组件的名称`。  
* 组件内的内部样式，使用SCSS规则写在其selector内。尽量使用无名规则和class规则，并使用`>`连接。

### layouts
这里的组件也是有强业务特征的、重型的组件；对业务有一定关联；存在跨视图使用。  
这里的组件大多也要使用文件夹分域存储，与views内的规则相近。  
* 主组件的css selector应该为`#当前组件的名称`。
* 子组件则为`#主组件的名称 #当前组件的名称`。
* 组件内的内部样式，使用SCSS规则写在其selector内。尽量使用无名规则和class规则，并使用`>`连接。

### components
这里的组件通常是无业务关联的、轻型的组件。  
这里的组件大多使用单独的文件存储。  
这里的CSS样式尽量选择`CSS-in-JS`。如果不能，尽量使用内部class样式，顶层样式与组件名称相关联。

### styles
首先，styles文件夹下有一个`index.ts`文件。所有在这里的CSS文件都在这个文件里导入，统一处理。然后在`main.ts`中导入`@/styles`。  
随后，公共样式也分为很多种，按照文件夹分类存储：
```
index.ts        -- 公共import文件
bulma/          -- bulma相关的外部导入样式
    bulma.scss          -- 有选择地导入bulma样式
    color.scss          -- 自定义的bulma颜色样式
components/     -- 自定义的组件样式
    ...                 -- 每个文件定义一个组件样式
utils/          -- 自定义的工具样式
    format.scss         -- 文本和显示格式相关的样式
    layout.scss         -- 元素布局相关的样式
    display.scss        -- 元素外观和显示相关的样式
```
#### components
这里定义一些具有组件特征的样式，类似bulma的组件，这些样式应用给元素后表现出某些强烈的功能和布局特征，而不具有工具和微调性。  
每个文件定义一个组件样式，或一组相近的组件样式。这些样式中的主样式以`h-`开头。
#### bulma
这里定义bulma相关的样式。
#### utils
这里主要是工具样式，以及对bulma扩展的工具样式。

### routers
这里定义程序的路由规则。

### functions
这里定义业务相关的函数库。  
以文件夹为单位分开定义。大部分情况下，这里的产出会是`vue hooks`函数或插件。
* `api`: 与后方对接的相关库。包括接口定义、http API对接实现、IPC对接实现、client的preloads注入识别。在client或web模式下提供的接口定义保持一致。
* `state`: 前端的大业务层。在api和ipc的基础上进行包装，将所有后端、客户端提供的功能包装为hooks函数提供服务。
* `document`: 与web document相关的功能的hooks函数。
* `http`: 通用的http API接入hooks函数，包括request模式和SWR模式。
* `notification`: 提供消息通知框服务。
* `message-box`: 提供简单对话框服务。

### utils
这里定义业务无关的工具函数库。

## Tips
### 状态共享和数据传递
在vue中，有两种方式在组件之间传递共享的数据。这两种方式在本项目中如何使用存在明确的规定。
#### provide/inject
在主体视图中，与业务强关联，视图很重，各个组件构成组件树，耦合性很强。此时，主要数据由`provide/inject`来提供。  
具有关联性质的数据(例如同一个功能视图中的数据)需要被提升到一个共同的父组件中，在此定义重量级的数据结构，并`provide`。在使用到数据的子组件`inject`。

此外，还存在一些并非主体业务的重型组件，需要使用`provide/inject`提升效率。但尽量不应该让这些组件通过`injectionKey`对外提供数据。

总结，依赖注入用于：
* 强关联、强业务的数据视图在组件树内向下共享。
* 在重型组件内优化数据传递效率。

### props/emits
在主体业务内，不属于视图共享的、只在一部分组件之间传递内容，显然不应该提升到数据视图中。这部分数据应该使用`props/emits`来传递。

此外，轻型组件、无业务关联的独立组件(`layouts`/`components`中的组件)，它们仍然应该使用属性对外传递数据。

总结，属性用于：
* 强业务的组件树内，局部的数据传递。
* 独立组件、无业务组件、轻量组件的对外数据传递。
